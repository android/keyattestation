/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.keyattestation.verifier.testing

import com.android.keyattestation.verifier.AuthorizationList
import com.android.keyattestation.verifier.KeyDescription
import com.android.keyattestation.verifier.KeyMintTag
import com.android.keyattestation.verifier.Origin
import com.android.keyattestation.verifier.RootOfTrust
import com.android.keyattestation.verifier.SecurityLevel
import com.android.keyattestation.verifier.VerifiedBootState
import com.android.keyattestation.verifier.provider.KeyAttestationCertPath
import com.google.protobuf.kotlin.toByteStringUtf8
import java.math.BigInteger
import java.security.cert.TrustAnchor
import org.bouncycastle.asn1.ASN1Encodable
import org.bouncycastle.asn1.ASN1EncodableVector
import org.bouncycastle.asn1.ASN1Enumerated
import org.bouncycastle.asn1.ASN1Integer
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.DEROctetString
import org.bouncycastle.asn1.DERSequence
import org.bouncycastle.asn1.DERTaggedObject
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.Extension

object ObjectIds {
  internal val KEY_DESCRIPTION = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17")
}

private val certFactory = KeyAttestationCertFactory()
private val fakeCalendar = certFactory.fakeCalendar

/** Useful certs and keys if using {@link CertLists} objects for testing. */
object Certs {
  val root = certFactory.root
  val rootAnchor = TrustAnchor(certFactory.root, null)
  val rootKey = certFactory.rootKey
  val factoryIntermediate = certFactory.factoryIntermediate
  val remoteIntermediate = certFactory.remoteIntermediate
  val strongBoxIntermediate = certFactory.strongBoxIntermediate
  val factoryAttestation = certFactory.factoryAttestation
}

/**
 * "Certificate lists" for testing [CertPath] construction
 *
 * A list of [X509Certificate]s in the order they are generated by Android Keystore.
 */
object CertLists {
  private val TEST_ATTESTATION_SERIAL_NUMBER = BigInteger.valueOf(0xf00d)

  /* A chain that is missing the leaf certificate. */
  val noLeaf by lazy {
    listOf(Certs.factoryAttestation, Certs.factoryIntermediate, certFactory.root)
  }

  /* A chain that has another certificate with an attestation extension after the target. */
  val extended by lazy {
    val leafCert = certFactory.generateLeafCert()
    listOf(
      certFactory.generateLeafCert(
        certFactory.leafKey.public,
        certFactory.leafKey.private,
        leafCert.subject,
      ),
      leafCert,
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A valid TEE factory provisioned chain. */
  @JvmStatic
  val validFactoryProvisioned by lazy {
    listOf(
      certFactory.generateLeafCert(),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A valid StrongBox factory provisioned chain. */
  val validStrongboxFactoryProvisioned by lazy {
    listOf(
      certFactory.generateLeafCert(extension = certFactory.STRONG_BOX_KEY_DESCRIPTION_EXT),
      certFactory.generateAttestationCert(issuer = Certs.strongBoxIntermediate.subject),
      Certs.strongBoxIntermediate,
      Certs.root,
    )
  }

  /* A valid remotely provisioned chain for TEE keys. */
  val validRemotelyProvisioned by lazy {
    val rkpAttestationCert =
      certFactory.generateRkpAttestationCert(
        securityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
        serialNumber = TEST_ATTESTATION_SERIAL_NUMBER,
      )
    listOf(
      certFactory.generateLeafCert(issuer = rkpAttestationCert.subject),
      rkpAttestationCert,
      certFactory.rkpIntermediate,
      Certs.remoteIntermediate,
      certFactory.root,
    )
  }

  /* A valid remotely provisioned chain for StrongBox keys. */
  val validStrongBoxRemotelyProvisioned by lazy {
    val rkpAttestationCert =
      certFactory.generateRkpAttestationCert(
        securityLevel = SecurityLevel.STRONG_BOX,
        serialNumber = TEST_ATTESTATION_SERIAL_NUMBER,
      )
    listOf(
      certFactory.generateLeafCert(
        extension = certFactory.STRONG_BOX_KEY_DESCRIPTION_EXT,
        issuer = rkpAttestationCert.subject,
      ),
      rkpAttestationCert,
      certFactory.rkpIntermediate,
      Certs.remoteIntermediate,
      certFactory.root,
    )
  }

  /* A valid chain that has a different trust anchor. */
  val wrongTrustAnchor by lazy {
    val anchorKeyPair = certFactory.generateEcKeyPair()
    val anchorSubject = X500Name("SERIALNUMBER=g00dc0de")
    listOf(
      certFactory.generateLeafCert(),
      Certs.factoryAttestation,
      certFactory.generateIntermediateCertificate(
        signingKey = anchorKeyPair.private,
        issuer = anchorSubject,
      ),
      certFactory.generateRootCertificate(keyPair = anchorKeyPair, subject = anchorSubject),
    )
  }

  /* A chain that has a malformed boot patch level. */
  val invalidBootPatchLevel by lazy {
    listOf(
      generateValidLeafCertWithAppendedTag(
        KeyMintTag.BOOT_PATCH_LEVEL.value,
        ASN1Integer(BigInteger.valueOf(20000000)),
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain that has a malformed vendor patch level. */
  val invalidVendorPatchLevel by lazy {
    listOf(
      generateValidLeafCertWithAppendedTag(
        KeyMintTag.VENDOR_PATCH_LEVEL.value,
        ASN1Integer(BigInteger.valueOf(1234567)),
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain that has a malformed OS patch level. */
  val invalidOsPatchLevel by lazy {
    listOf(
      generateValidLeafCertWithAppendedTag(
        KeyMintTag.OS_PATCH_LEVEL.value,
        ASN1Integer(BigInteger.valueOf(0)),
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the key tags are out of order. */
  val unorderedTags by lazy {
    listOf(
      // Append the key size tag, which has a lower tag number than either of the required tags
      // (origin and root of trust).
      generateValidLeafCertWithAppendedTag(
        KeyMintTag.KEY_SIZE.value,
        ASN1Integer(BigInteger.valueOf(32)),
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the key description has an unknown tag. */
  val unknownTag by lazy {
    listOf(
      generateValidLeafCertWithAppendedTag(1000, ASN1Integer(BigInteger.valueOf(2048))),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where there is a certificate after the target certificate with the attestation extension. */
  val certAfterTarget by lazy {
    listOf(
      certFactory.generateLeafCert(
        publicKey = certFactory.generateEcKeyPair().public,
        signingKey = certFactory.leafKey.private,
        extension = null,
        subject = X500Name("CN=Random leaf after the leaf"),
      ),
      certFactory.generateLeafCert(),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate has an unparseable extension. */
  @JvmStatic
  val unparseableExtension by lazy {
    listOf(
      certFactory.generateLeafCert(
        extension =
          Extension(ObjectIds.KEY_DESCRIPTION, /* critical= */ false, byteArrayOf(0x42, 0x42))
      ),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate has an extension with a missing value. */
  @JvmStatic
  val missingExtension by lazy {
    listOf(
      certFactory.generateLeafCert(extension = null),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate is missing the root of trust. This is malformed. */
  val missingRootOfTrust by lazy {
    listOf(
      certFactory.generateLeafCert(
        extension =
          KeyDescription(
              attestationVersion = BigInteger.valueOf(300),
              attestationSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
              keyMintVersion = BigInteger.valueOf(300),
              keyMintSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
              attestationChallenge = "challenge".toByteStringUtf8(),
              uniqueId = "uniqueId".toByteStringUtf8(),
              softwareEnforced = AuthorizationList(),
              hardwareEnforced = AuthorizationList(origin = Origin.GENERATED),
            )
            .asExtension()
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the origin is IMPORTED. This should not be trusted. */
  val importedOrigin by lazy {
    listOf(
      certFactory.generateLeafCert(
        extension =
          KeyDescription(
              attestationVersion = BigInteger.valueOf(300),
              attestationSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
              keyMintVersion = BigInteger.valueOf(300),
              keyMintSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
              attestationChallenge = "challenge".toByteStringUtf8(),
              uniqueId = "uniqueId".toByteStringUtf8(),
              softwareEnforced = AuthorizationList(),
              hardwareEnforced =
                AuthorizationList(
                  rootOfTrust =
                    RootOfTrust("bootKey".toByteStringUtf8(), true, VerifiedBootState.VERIFIED),
                  origin = Origin.IMPORTED,
                ),
            )
            .asExtension()
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the KeyMint security level does not match the attestation security level. */
  val mismatchedSecurityLevels by lazy {
    listOf(
      certFactory.generateLeafCert(
        extension =
          KeyDescription(
              attestationVersion = BigInteger.valueOf(300),
              attestationSecurityLevel = SecurityLevel.SOFTWARE,
              keyMintVersion = BigInteger.valueOf(300),
              keyMintSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
              attestationChallenge = "challenge".toByteStringUtf8(),
              uniqueId = "uniqueId".toByteStringUtf8(),
              softwareEnforced = AuthorizationList(),
              hardwareEnforced =
                AuthorizationList(
                  rootOfTrust =
                    RootOfTrust("bootKey".toByteStringUtf8(), true, VerifiedBootState.VERIFIED),
                  origin = Origin.GENERATED,
                ),
            )
            .asExtension()
      ),
      certFactory.factoryAttestation,
      certFactory.factoryIntermediate,
      certFactory.root,
    )
  }

  private fun generateValidLeafCertWithAppendedTag(appendedTag: Int, appendedValue: ASN1Encodable) =
    certFactory.generateLeafCert(
      extension =
        Extension(
          KeyDescription.OID,
          /* critical= */ false,
          buildList {
              add(ASN1Integer(BigInteger.valueOf(300))) // attestationVersion
              add(ASN1Enumerated(1)) // attestationSecurityLevel
              add(ASN1Integer(BigInteger.valueOf(300))) // keyMintVersion
              add(ASN1Enumerated(1)) // keyMintSecurityLevel
              add(DEROctetString(byteArrayOf(98, 99, 100))) // attestationChallenge
              add(DEROctetString(byteArrayOf(100, 101, 102))) // uniqueId
              add(DERSequence(ASN1EncodableVector())) // softwareEnforced
              // hardwareEnforced, with the appended tag
              add(
                buildList {
                    add(DERTaggedObject(KeyMintTag.ORIGIN.value, Origin.GENERATED.toAsn1()))
                    add(
                      DERTaggedObject(
                        KeyMintTag.ROOT_OF_TRUST.value,
                        RootOfTrust("bootKey".toByteStringUtf8(), true, VerifiedBootState.VERIFIED)
                          .toAsn1(),
                      )
                    )
                    add(DERTaggedObject(appendedTag, appendedValue))
                  }
                  .let { DERSequence(it.toTypedArray()) }
              )
            }
            .let { DERSequence(it.toTypedArray()).encoded },
        )
    )
}

object Chains {
  @Deprecated("Use CertLists.validFactoryProvisioned instead")
  @JvmStatic
  val valid = KeyAttestationCertPath(CertLists.validFactoryProvisioned)

  @JvmStatic val validFactoryProvisioned = KeyAttestationCertPath(CertLists.validFactoryProvisioned)

  @JvmStatic
  val validRemotelyProvisioned by lazy {
    KeyAttestationCertPath(CertLists.validRemotelyProvisioned)
  }

  @JvmStatic val wrongTrustAnchor by lazy { KeyAttestationCertPath(CertLists.wrongTrustAnchor) }

  /* A chain where the intermediate certificate has a mismatched subject. */
  val wrongIntermediateSubject by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(),
      Certs.factoryAttestation,
      certFactory.generateIntermediateCertificate(subject = X500Name("O=Unexpected Inc.")),
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate has a mismatched issuer. */
  @JvmStatic
  val wrongIssuer by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(issuer = X500Name("O=Unexpected Inc.")),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where one of the signatures won't verify. */
  @JvmStatic
  val wrongSignature by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(signingKey = certFactory.generateEcKeyPair().private),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate has a mismatched algorithm. */
  val wrongAlgorithm by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(signingKey = certFactory.generateRsaKeyPair().private),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the attestation certificate is not yet valid. */
  val notYetValid by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(),
      certFactory.generateAttestationCert(
        notBefore = fakeCalendar.nextWeek(),
        notAfter = fakeCalendar.nextWeek(),
      ),
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the attestation certificate has expired. */
  @JvmStatic
  val expired by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(),
      certFactory.generateAttestationCert(
        notBefore = fakeCalendar.lastWeek(),
        notAfter = fakeCalendar.lastWeek(),
      ),
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A chain where the leaf certificate has expired. This will pass. */
  val expiredLeaf by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(
        notBefore = fakeCalendar.lastWeek(),
        notAfter = fakeCalendar.lastWeek(),
      ),
      Certs.factoryAttestation,
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* Different revoked serial numbers for testing. */
  @JvmField val REVOKED_SERIAL_NUMBER = 42.toBigInteger()
  @JvmField val REVOKED_SERIAL_NUMBER_BIG = 8000000000000.toBigInteger()
  @JvmField
  val REVOKED_SERIAL_NUMBER_LONG_STRING = "c35747a084470c3135aeefe2b8d40cd6".toBigInteger(16)
  @JvmField val REVOKED_SERIAL_NUMBER_ODD_LENGTH = 1228286566665971148.toBigInteger()

  /* A chain where the attesstation certificate has {@link REVOKED_SERIAL_NUMBER}. */
  @JvmStatic
  val revoked by lazy {
    KeyAttestationCertPath(
      certFactory.generateLeafCert(),
      certFactory.generateAttestationCert(serialNumber = REVOKED_SERIAL_NUMBER),
      Certs.factoryIntermediate,
      certFactory.root,
    )
  }

  /* A factory chain with an additional intermediate certificate. */
  val forgedKeybox by lazy {
    val compromisedAttestationKey = certFactory.generateEcKeyPair()
    val name = X500Name("O=Honest Achmed's Used Cars and Certificates")
    KeyAttestationCertPath(
      certFactory.generateLeafCert(),
      // Attestation certificate signed by the attacker created keybox
      certFactory.generateAttestationCert(
        signingKey = compromisedAttestationKey.private,
        issuer = name,
      ),
      // Attacker created keybox signed by the compromised keybox
      certFactory.generateIntermediateCertificate(
        compromisedAttestationKey.public,
        certFactory.intermediateKey.private,
        subject = name,
        issuer = Certs.factoryIntermediate.subject,
      ),
      // Google signed keybox that was compromised
      Certs.factoryIntermediate,
      // Google signed root certificate
      Certs.root,
    )
  }
}
