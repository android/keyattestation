/*
 * Copyright 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.android.keyattestation.verifier.testing

import com.android.keyattestation.verifier.AuthorizationList
import com.android.keyattestation.verifier.KeyDescription
import com.android.keyattestation.verifier.SecurityLevel
import com.android.keyattestation.verifier.provider.KeyAttestationCertPath
import com.google.protobuf.ByteString
import java.math.BigInteger
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.PrivateKey
import java.security.PublicKey
import java.security.SecureRandom
import java.security.cert.CertificateFactory
import java.security.cert.TrustAnchor
import java.security.cert.X509Certificate
import java.security.interfaces.ECPrivateKey
import java.security.interfaces.RSAPrivateKey
import java.security.spec.ECGenParameterSpec
import java.security.spec.RSAKeyGenParameterSpec
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.util.Date
import java.util.Random
import javax.security.auth.x500.X500Principal
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX500NameUtil
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder

object ObjectIds {
  internal val KEY_DESCRIPTION = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17")
  internal val PROVISIONING_INFO = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.30")
}

private val ecKeyPairGenerator: KeyPairGenerator by lazy {
  KeyPairGenerator.getInstance("EC").apply {
    initialize(ECGenParameterSpec("secp256r1"), FakeSecureRandom())
  }
}

private val rsaKeyPairGenerator: KeyPairGenerator by lazy {
  KeyPairGenerator.getInstance("RSA").apply {
    initialize(RSAKeyGenParameterSpec(512, RSAKeyGenParameterSpec.F4), FakeSecureRandom())
  }
}

private val rootKey = ecKeyPairGenerator.generateKeyPair()
private val intermediateKey = ecKeyPairGenerator.generateKeyPair()
private val attestationKey = ecKeyPairGenerator.generateKeyPair()
private val leafKey = ecKeyPairGenerator.generateKeyPair()

object Certs {
  @JvmField val root = generateRootCertificate()
  val rootAnchor = TrustAnchor(root, null)
  val factoryIntermediate = generateIntermediateCertificate()
  val remoteIntermediate =
    generateIntermediateCertificate(subject = X500Name("O=Google LLC, CN=Droid CA9000"))
  val attestation = generateAttestationCert()
}

/**
 * "Certificate lists" for testing [CertPath] construction
 *
 * A list of [X509Certificate]s in the order they are generated by Android Keystore.
 */
object CertLists {
  val noLeaf by lazy { listOf(Certs.attestation, Certs.factoryIntermediate, Certs.root) }

  val extended by lazy {
    val leafCert = generateLeafCert()
    listOf(
      generateLeafCert(leafKey.public, leafKey.private, leafCert.subject),
      leafCert,
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val validFactoryProvisioned by lazy {
    listOf(generateLeafCert(), Certs.attestation, Certs.factoryIntermediate, Certs.root)
  }

  val validRemotelyProvisioned by lazy {
    val rkpKey = ecKeyPairGenerator.generateKeyPair()
    val rkpName = X500Name("CN=RKP")
    val rkpIntermediate =
      generateIntermediateCertificate(
        publicKey = rkpKey.public,
        signingKey = intermediateKey.private,
        subject = rkpName,
        issuer = Certs.remoteIntermediate.subject,
      )
    val attestationCertWithProvisioningInfoExt =
      generateAttestationCert(
        signingKey = rkpKey.private,
        issuer = rkpIntermediate.subject,
        extraExtension =
          Extension(ObjectIds.PROVISIONING_INFO, /* critical= */ false, byteArrayOf()),
      )
    listOf(
      generateLeafCert(),
      attestationCertWithProvisioningInfoExt,
      rkpIntermediate,
      Certs.remoteIntermediate,
      Certs.root,
    )
  }

  val wrongTrustAnchor by lazy {
    val anchorKeyPair = ecKeyPairGenerator.generateKeyPair()
    val anchorSubject = X500Name("SERIALNUMBER=g00dc0de")
    listOf(
      generateLeafCert(),
      Certs.attestation,
      generateIntermediateCertificate(signingKey = anchorKeyPair.private, issuer = anchorSubject),
      generateRootCertificate(keyPair = anchorKeyPair, subject = anchorSubject),
    )
  }
}

object Chains {
  @Deprecated("Use CertLists.validFactoryProvisioned instead")
  @JvmStatic
  val valid = KeyAttestationCertPath(CertLists.validFactoryProvisioned)

  @JvmStatic val validFactoryProvisioned = KeyAttestationCertPath(CertLists.validFactoryProvisioned)

  @JvmStatic
  val validRemotelyProvisioned by lazy {
    KeyAttestationCertPath(CertLists.validRemotelyProvisioned)
  }

  @JvmStatic val wrongTrustAnchor by lazy { KeyAttestationCertPath(CertLists.wrongTrustAnchor) }

  val wrongIntermediateSubject by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      Certs.attestation,
      generateIntermediateCertificate(subject = X500Name("O=Unexpected Inc.")),
      Certs.root,
    )
  }

  @JvmStatic
  val wrongIssuer by lazy {
    KeyAttestationCertPath(
      generateLeafCert(issuer = X500Name("O=Unexpected Inc.")),
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val wrongSignature by lazy {
    KeyAttestationCertPath(
      generateLeafCert(signingKey = ecKeyPairGenerator.generateKeyPair().private),
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  val wrongAlgorithm by lazy {
    KeyAttestationCertPath(
      generateLeafCert(signingKey = rsaKeyPairGenerator.generateKeyPair().private),
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  val notYetValid by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(
        notBefore = FakeCalendar.tomorrow(),
        notAfter = FakeCalendar.tomorrow(),
      ),
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val expired by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(
        notBefore = FakeCalendar.yesterday(),
        notAfter = FakeCalendar.yesterday(),
      ),
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  val expiredLeaf by lazy {
    KeyAttestationCertPath(
      generateLeafCert(notBefore = FakeCalendar.yesterday(), notAfter = FakeCalendar.yesterday()),
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val unparseableExtension by lazy {
    KeyAttestationCertPath(
      generateLeafCert(
        extension =
          Extension(ObjectIds.KEY_DESCRIPTION, /* critical= */ false, byteArrayOf(0x42, 0x42))
      ),
      Certs.attestation,
      Certs.factoryIntermediate,
      Certs.root,
    )
  }

  @JvmField val REVOKED_SERIAL_NUMBER = 42.toBigInteger()
  @JvmField val REVOKED_SERIAL_NUMBER_BIG = 8000000000000.toBigInteger()
  @JvmField
  val REVOKED_SERIAL_NUMBER_LONG_STRING = "c35747a084470c3135aeefe2b8d40cd6".toBigInteger(16)
  @JvmField val REVOKED_SERIAL_NUMBER_ODD_LENGTH = 1228286566665971148.toBigInteger()

  @JvmStatic
  val revoked by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(serialNumber = REVOKED_SERIAL_NUMBER),
      Certs.factoryIntermediate,
      Certs.root,
    )
  }
}

val BASIC_CONSTRAINTS_EXT =
  Extension(
    Extension.basicConstraints,
    /* critical= */ true,
    BasicConstraints(/* cA= */ true).encoded,
  )

object KeyAttestationCertPathFactory {
  @JvmOverloads
  @JvmStatic
  fun generateCertPath(
    keyDescription: KeyDescription,
    remotelyProvisioned: Boolean = false,
  ): KeyAttestationCertPath {
    val attestationCertExtension =
      Extension(ObjectIds.PROVISIONING_INFO, /* critical= */ false, byteArrayOf()).takeIf {
        remotelyProvisioned
      }
    return KeyAttestationCertPath(
      generateLeafCert(extension = keyDescription.asExtension()),
      generateAttestationCert(extraExtension = attestationCertExtension),
      Certs.factoryIntermediate,
      Certs.root,
    )
  }
}

private fun generateRootCertificate(
  keyPair: KeyPair = rootKey,
  subject: X500Name = X500Name("SERIALNUMBER=badc0de"),
) =
  generateCertificate(
    keyPair.public,
    keyPair.private,
    subject,
    subject,
    extensions = listOf(BASIC_CONSTRAINTS_EXT),
  )

private fun generateIntermediateCertificate(
  publicKey: PublicKey = intermediateKey.public,
  signingKey: PrivateKey = rootKey.private,
  subject: X500Name = X500Name("SERIALNUMBER=e18c4f2ca699739a, T=TEE"),
  issuer: X500Name = Certs.root.subject,
) =
  generateCertificate(
    publicKey,
    signingKey,
    subject,
    issuer,
    extensions = listOf(BASIC_CONSTRAINTS_EXT),
  )

private fun generateAttestationCert(
  signingKey: PrivateKey = intermediateKey.private,
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  issuer: X500Name = Certs.factoryIntermediate.subject,
  serialNumber: BigInteger = BigInteger.ZERO,
  extraExtension: Extension? = null,
) =
  generateCertificate(
    attestationKey.public,
    signingKey,
    X500Name("serialNumber=decafbad"),
    issuer,
    serialNumber,
    notBefore,
    notAfter,
    extensions = listOfNotNull(BASIC_CONSTRAINTS_EXT, extraExtension),
  )

private val KEY_DESCRIPTION_EXT =
  KeyDescription(
      attestationVersion = 1.toBigInteger(),
      attestationSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
      keymasterVersion = 1.toBigInteger(),
      keymasterSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
      attestationChallenge = ByteString.copyFromUtf8("challenge"),
      uniqueId = ByteString.empty(),
      softwareEnforced = AuthorizationList(),
      teeEnforced = AuthorizationList(),
    )
    .asExtension()

private fun generateLeafCert(
  publicKey: PublicKey = leafKey.public,
  signingKey: PrivateKey = attestationKey.private,
  subject: X500Name = X500Name("CN=Android Keystore Key"),
  issuer: X500Name = Certs.attestation.subject,
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  extension: Extension? = KEY_DESCRIPTION_EXT,
): X509Certificate =
  generateCertificate(
    publicKey,
    signingKey,
    subject,
    issuer,
    notBefore = notBefore,
    notAfter = notAfter,
    extensions = extension?.let { listOf(it) } ?: emptyList(),
  )

private fun generateCertificate(
  publicKey: PublicKey,
  signingKey: PrivateKey,
  subject: X500Name,
  issuer: X500Name,
  serialNumber: BigInteger = BigInteger.ZERO,
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  extensions: List<Extension> = emptyList<Extension>(),
): X509Certificate {
  val builder =
    JcaX509v3CertificateBuilder(issuer, serialNumber, notBefore, notAfter, subject, publicKey)
  extensions.forEach(builder::addExtension)
  return builder.sign(signingKey.asSigner())
}

private val certificateFactory = CertificateFactory.getInstance("X.509")

private fun PrivateKey.asSigner(): ContentSigner {
  val signatureAlgorithm =
    when (this) {
      is ECPrivateKey -> "SHA256WithECDSA"
      is RSAPrivateKey -> "SHA256WithRSA"
      else -> throw IllegalArgumentException("Unsupported private key type: ${this::class}")
    }
  return JcaContentSignerBuilder(signatureAlgorithm).build(this)
}

private fun X500Principal.asX500Name() = JcaX500NameUtil.getX500Name(this)

private val X509Certificate.subject: X500Name
  get() = subjectX500Principal.asX500Name()

private fun X509CertificateHolder.asX509Certificate() =
  JcaX509CertificateConverter().getCertificate(this)

private fun X509v3CertificateBuilder.sign(signer: ContentSigner) =
  this.build(signer).asX509Certificate()

private class FakeSecureRandom : SecureRandom() {
  private val random = Random(0)

  override fun nextBytes(bytes: ByteArray) {
    random.nextBytes(bytes)
  }
}

object FakeCalendar {
  private val today = LocalDate.of(2024, 10, 20)

  @JvmStatic fun today(): Date = today.toDate()

  @JvmStatic fun now(): Instant = today.atStartOfDay(ZoneId.of("UTC")).toInstant()

  fun yesterday(): Date = today.minusDays(1).toDate()

  fun tomorrow(): Date = today.plusDays(1).toDate()

  private fun Instant.toDate() = Date.from(this)

  private fun LocalDate.toDate() = this.atStartOfDay(ZoneId.of("UTC")).toInstant().toDate()
}
