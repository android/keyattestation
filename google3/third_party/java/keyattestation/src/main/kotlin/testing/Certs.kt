package com.android.keyattestation.verifier.testing

import com.android.keyattestation.verifier.AuthorizationList
import com.android.keyattestation.verifier.KeyDescription
import com.android.keyattestation.verifier.SecurityLevel
import com.android.keyattestation.verifier.provider.KeyAttestationCertPath
import com.google.protobuf.ByteString
import java.math.BigInteger
import java.security.KeyPair
import java.security.KeyPairGenerator
import java.security.PrivateKey
import java.security.PublicKey
import java.security.SecureRandom
import java.security.cert.CertificateFactory
import java.security.cert.TrustAnchor
import java.security.cert.X509Certificate
import java.security.interfaces.ECPrivateKey
import java.security.interfaces.RSAPrivateKey
import java.security.spec.ECGenParameterSpec
import java.security.spec.RSAKeyGenParameterSpec
import java.time.Instant
import java.time.LocalDate
import java.time.ZoneId
import java.util.Date
import java.util.Random
import javax.security.auth.x500.X500Principal
import org.bouncycastle.asn1.ASN1ObjectIdentifier
import org.bouncycastle.asn1.x500.X500Name
import org.bouncycastle.asn1.x509.BasicConstraints
import org.bouncycastle.asn1.x509.Extension
import org.bouncycastle.cert.X509CertificateHolder
import org.bouncycastle.cert.X509v3CertificateBuilder
import org.bouncycastle.cert.jcajce.JcaX500NameUtil
import org.bouncycastle.cert.jcajce.JcaX509CertificateConverter
import org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder
import org.bouncycastle.operator.ContentSigner
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder

object ObjectIds {
  internal val KEY_DESCRIPTION = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.17")
  internal val PROVISIONING_INFO = ASN1ObjectIdentifier("1.3.6.1.4.1.11129.2.1.30")
}

private val ecKeyPairGenerator: KeyPairGenerator by lazy {
  KeyPairGenerator.getInstance("EC").apply {
    initialize(ECGenParameterSpec("secp256r1"), FakeSecureRandom())
  }
}

private val rsaKeyPairGenerator: KeyPairGenerator by lazy {
  KeyPairGenerator.getInstance("RSA").apply {
    initialize(RSAKeyGenParameterSpec(512, RSAKeyGenParameterSpec.F4), FakeSecureRandom())
  }
}

private val rootKey = ecKeyPairGenerator.generateKeyPair()
private val intermediateKey = ecKeyPairGenerator.generateKeyPair()
private val attestationKey = ecKeyPairGenerator.generateKeyPair()
private val leafKey = ecKeyPairGenerator.generateKeyPair()

object Certs {
  @JvmField val root = generateRootCertificate()
  val rootAnchor = TrustAnchor(root, null)
  val intermediate = generateIntermediateCertificate()
  val attestation = generateAttestationCert()
}

/**
 * "Certificate lists" for testing [CertPath] construction
 *
 * A list of [X509Certificate]s in the order they are generated by Android Keystore.
 */
object CertLists {
  val noLeaf by lazy { listOf(Certs.attestation, Certs.intermediate, Certs.root) }

  val extended by lazy {
    val leafCert = generateLeafCert()
    listOf(
      generateLeafCert(leafKey.public, leafKey.private, leafCert.subject),
      leafCert,
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val valid by lazy {
    listOf(generateLeafCert(), Certs.attestation, Certs.intermediate, Certs.root)
  }

  val remotelyProvisioned by lazy {
    val attestationCertWithProvisioningInfoExt =
      generateAttestationCert(
        extraExtension =
          Extension(ObjectIds.PROVISIONING_INFO, /* critical= */ false, byteArrayOf())
      )
    listOf(
      generateLeafCert(),
      attestationCertWithProvisioningInfoExt,
      Certs.intermediate,
      Certs.root,
    )
  }

  val wrongTrustAnchor by lazy {
    val anchorKeyPair = ecKeyPairGenerator.generateKeyPair()
    val anchorSubject = X500Name("SERIALNUMBER=g00dc0de")
    listOf(
      generateLeafCert(),
      Certs.attestation,
      generateIntermediateCertificate(signingKey = anchorKeyPair.private, issuer = anchorSubject),
      generateRootCertificate(keyPair = anchorKeyPair, subject = anchorSubject),
    )
  }
}

object Chains {
  @JvmStatic val valid by lazy { KeyAttestationCertPath(CertLists.valid) }

  @JvmStatic
  val remotelyProvisioned by lazy { KeyAttestationCertPath(CertLists.remotelyProvisioned) }

  @JvmStatic val wrongTrustAnchor by lazy { KeyAttestationCertPath(CertLists.wrongTrustAnchor) }

  @JvmStatic
  val wrongIssuer by lazy {
    KeyAttestationCertPath(
      generateLeafCert(issuer = X500Name("O=Unexpected Inc.")),
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val wrongSignature by lazy {
    KeyAttestationCertPath(
      generateLeafCert(signingKey = ecKeyPairGenerator.generateKeyPair().private),
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  val wrongAlgorithm by lazy {
    KeyAttestationCertPath(
      generateLeafCert(signingKey = rsaKeyPairGenerator.generateKeyPair().private),
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  val notYetValid by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(FakeCalendar.tomorrow(), FakeCalendar.tomorrow()),
      Certs.intermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val expired by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(FakeCalendar.yesterday(), FakeCalendar.yesterday()),
      Certs.intermediate,
      Certs.root,
    )
  }

  val expiredLeaf by lazy {
    KeyAttestationCertPath(
      generateLeafCert(notBefore = FakeCalendar.yesterday(), notAfter = FakeCalendar.yesterday()),
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  @JvmStatic
  val unparseableExtension by lazy {
    KeyAttestationCertPath(
      generateLeafCert(
        extension =
          Extension(ObjectIds.KEY_DESCRIPTION, /* critical= */ false, byteArrayOf(0x42, 0x42))
      ),
      Certs.attestation,
      Certs.intermediate,
      Certs.root,
    )
  }

  @JvmField val REVOKED_SERIAL_NUMBER = 42.toBigInteger()

  @JvmStatic
  val revoked by lazy {
    KeyAttestationCertPath(
      generateLeafCert(),
      generateAttestationCert(serialNumber = REVOKED_SERIAL_NUMBER),
      Certs.intermediate,
      Certs.root,
    )
  }
}

val BASIC_CONSTRAINTS_EXT =
  Extension(
    Extension.basicConstraints,
    /* critical= */ true,
    BasicConstraints(/* cA= */ true).encoded,
  )

object KeyAttestationCertPathFactory {
  @JvmOverloads
  @JvmStatic
  fun generateCertPath(
    keyDescription: KeyDescription,
    remotelyProvisioned: Boolean = false,
  ): KeyAttestationCertPath {
    val attestationCertExtension =
      Extension(ObjectIds.PROVISIONING_INFO, /* critical= */ false, byteArrayOf()).takeIf {
        remotelyProvisioned
      }
    return KeyAttestationCertPath(
      generateLeafCert(extension = keyDescription.asExtension()),
      generateAttestationCert(extraExtension = attestationCertExtension),
      Certs.intermediate,
      Certs.root,
    )
  }
}

private fun generateRootCertificate(
  keyPair: KeyPair = rootKey,
  subject: X500Name = X500Name("SERIALNUMBER=badc0de"),
) =
  generateCertificate(
    keyPair.public,
    keyPair.private,
    subject,
    subject,
    extensions = listOf(BASIC_CONSTRAINTS_EXT),
  )

private fun generateIntermediateCertificate(
  signingKey: PrivateKey = rootKey.private,
  issuer: X500Name = Certs.root.subject,
) =
  generateCertificate(
    intermediateKey.public,
    signingKey,
    X500Name("O=Google LLC, CN=Droid CA9000"),
    issuer,
    extensions = listOf(BASIC_CONSTRAINTS_EXT),
  )

private fun generateAttestationCert(
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  serialNumber: BigInteger = BigInteger.ZERO,
  extraExtension: Extension? = null,
) =
  generateCertificate(
    attestationKey.public,
    intermediateKey.private,
    X500Name("serialNumber=decafbad"),
    Certs.intermediate.subject,
    serialNumber,
    notBefore,
    notAfter,
    extensions = listOfNotNull(BASIC_CONSTRAINTS_EXT, extraExtension),
  )

private val KEY_DESCRIPTION_EXT =
  KeyDescription(
      attestationVersion = 1.toBigInteger(),
      attestationSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
      keymasterVersion = 1.toBigInteger(),
      keymasterSecurityLevel = SecurityLevel.TRUSTED_ENVIRONMENT,
      attestationChallenge = ByteString.copyFromUtf8("challenge"),
      uniqueId = ByteString.empty(),
      softwareEnforced = AuthorizationList(),
      teeEnforced = AuthorizationList(),
    )
    .asExtension()

private fun generateLeafCert(
  publicKey: PublicKey = leafKey.public,
  signingKey: PrivateKey = attestationKey.private,
  subject: X500Name = X500Name("CN=Android Keystore Key"),
  issuer: X500Name = Certs.attestation.subject,
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  extension: Extension? = KEY_DESCRIPTION_EXT,
): X509Certificate =
  generateCertificate(
    publicKey,
    signingKey,
    subject,
    issuer,
    notBefore = notBefore,
    notAfter = notAfter,
    extensions = extension?.let { listOf(it) } ?: emptyList(),
  )

private fun generateCertificate(
  publicKey: PublicKey,
  signingKey: PrivateKey,
  subject: X500Name,
  issuer: X500Name,
  serialNumber: BigInteger = BigInteger.ZERO,
  notBefore: Date = FakeCalendar.yesterday(),
  notAfter: Date = FakeCalendar.tomorrow(),
  extensions: List<Extension> = emptyList<Extension>(),
): X509Certificate {
  val builder =
    JcaX509v3CertificateBuilder(issuer, serialNumber, notBefore, notAfter, subject, publicKey)
  extensions.forEach(builder::addExtension)
  return builder.sign(signingKey.asSigner())
}

private val certificateFactory = CertificateFactory.getInstance("X.509")

private fun PrivateKey.asSigner(): ContentSigner {
  val signatureAlgorithm =
    when (this) {
      is ECPrivateKey -> "SHA256WithECDSA"
      is RSAPrivateKey -> "SHA256WithRSA"
      else -> throw IllegalArgumentException("Unsupported private key type: ${this::class}")
    }
  return JcaContentSignerBuilder(signatureAlgorithm).build(this)
}

private fun X500Principal.asX500Name() = JcaX500NameUtil.getX500Name(this)

private val X509Certificate.subject: X500Name
  get() = subjectX500Principal.asX500Name()

private fun X509CertificateHolder.asX509Certificate() =
  JcaX509CertificateConverter().getCertificate(this)

private fun X509v3CertificateBuilder.sign(signer: ContentSigner) =
  this.build(signer).asX509Certificate()

private class FakeSecureRandom : SecureRandom() {
  private val random = Random(0)

  override fun nextBytes(bytes: ByteArray) {
    random.nextBytes(bytes)
  }
}

object FakeCalendar {
  private val today = LocalDate.of(2024, 10, 20)

  @JvmStatic fun today(): Date = today.toDate()

  fun yesterday(): Date = today.minusDays(1).toDate()

  fun tomorrow(): Date = today.plusDays(1).toDate()

  private fun Instant.toDate() = Date.from(this)

  private fun LocalDate.toDate() = this.atStartOfDay(ZoneId.of("UTC")).toInstant().toDate()
}
